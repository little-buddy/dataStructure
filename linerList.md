# 线性表
    元素之间存在一对一的线性关系

## 线性表的逻辑结构
>* n(n>=0) 个具有相同数据类型的数据元素的有限序列。线性表中数据元素的个数称为线性表的长度，长度等于0时称为空表
>* 除了队首与队尾，都只有一个前驱和一个后继
>* 线性表有的方法
> > - InitList 初始化
> > - DestroyList 摧毁
> > - length 长度
> > - get 获得
> > - locate 返回查找元素的下标
> > - insert 插入
> > - delete 删除
> > - empty 空
> > - printList 按序号依次输出元素

## 线性表的顺序存储结构及实现 【顺序表】
    线性表的顺序存储结构称为顺序表
    由一段地址连续的存储单元依次存储线性表的数据元素，由于线性表中的每个数据元素的类型相同，通常用一维数组来实现线性表
    又由于数组的下标是从0开始的，而现行表的下标是从1开始的，所以线性表第i个元素存储在数组下标为i-1的位置
    顺序表就意味着要分配固定长度的数组空间，必须确定数组的长度，即存放线性表的数组空间的长度

> 特点：
>> 顺序表中数据元素的存储地址是其序号的线性函数，只要确定了顺序表的其实地址，计算任意一个元素的存储地址时间相等。具有这一特点的存储结构称为 随机存取<br>
    按位查找 O(1)   按值查找 O(N)   插入、删除 O(N) 这些都是最基础的操作<br>
    ~~对于一个算法的参数校验来说，一般就是判断 是否越界~~

>缺点：<br>
> * 插入、删除操作需要移动大量的元素，等概率的情况下需要移动表中一半的元素
> * 表的容量难以确定，由于数组的长度必须事先确定，因此线性表的长度变化较大时难以确定合适的存储规模（这确实是初期在写C时的一个灾难）
> * 造成存储空间的"碎片"，因为顺序表要求连续的存储单元，即使存储单元超过所需的存储空间，不连续也不能使用，造成空间的碎片化<br>

>以上是静态存储分配的缺点，而链接存储结构就是采用动态存储分配<br>
`静态存储分配` 在编译的时为变量分配内存，并且一经分配就始终占有固定的存储单元，直到该变量退出其作用域<br>
`动态存储分配` 程序运行期间根据存储需要随时申请内存，并在不需要的时候释放


## 线性表的链接存储及实现 【链表】
### 单链表
> 用一组任意的存储单元用来存放线性表的元素，存储单元可以连续也可以不连续，甚至可以零散地分布在内存中的任意位置
为了能正确地表示数据元素之间的关系，每个存储单元在存储数据的同时还需要存储其后继元素所在的地址信息 这个地址信息 `指针` <br>
这两部分组成了数据元素的存储映像 `结点`  `|data -数据域|next -指针域|` <br>

>单链表每个结点的存储地址都存放在其前驱结点的next域中，而第一个元素无前驱，所以设 `头指针` 整个单链表的存储必须从头指针开始，因而头指针具有标识一个单链表的作用<br>
由于最后一个元素无后继，故最后一个元素所在结点的next域为空，即 NULL `尾标志`<br>
`头结点` 因为第一个元素无前驱需要特殊处理，为了避免算法的复杂性以及bug率，就在第一个元素前增加了data域为空的头结点，头指针一开始指向头结点<br>
单链表遍历算法 求线性表的长度算法 单链表按位查找算法 单链表按值查找算法 单链表插入算法 头插法建立单链表 尾插法建立单链表 单链表删除算法<br>
头插法其实就是在头结点与第一个元素之间插入元素 尾插法就是在最后一个元素之后插入一个结点

### 循环链表
    在单链表中，如果将终端结点的指针域由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为 `循环链表`
> 它的意义在于，对于单链表找到起始结点的时间复杂度为O(1)，而找到尾结点的时间复杂度为O(N)，一般对于链表的操作又多在队首或队尾<br>
所以才有了循环链表，但也因此有了一定的缺陷，就是没有判断循环结束的标志，也因此加了一个是否等于某个特定结点作为判断标志
<br> `顺序存取` 在查找成功的情况，若查找位置为i(1<=i<=n),则需要执行i-1次，等概率的情况下，时间复杂度为O(N)，这种称为顺序存取

### 双链表
    解决了单链表找尾结点的麻烦，又出来一个 寻找前驱结点的时间复杂度为O(N) 所以就又提出了一个双链表的概念

## 顺序表和链表的比较
    决定数据结构使用线性表的时候，就要考虑时间性能和空间性能来选择 顺序表还是链表
> 时间性能比较
<br> 插入和删除操作较多的时候，选择链表要比顺序表好，因为链表的时间复杂度为O(1) 而顺序表的时间复杂度为O(N)，频繁用于查找的则用线性表比较好
<br><br>空间性能比较
<br>`存储密度 = 数据域占用的存储量/整个结点占用的存储量`
<br> 顺序表中每个结点只存放数据元素，存储密度=1，而链表中每个结点存放数据元素之外还存储数据元素之间的指针关系，由此看来顺序表的存储空间利用率较高
<br> 又因为顺序表需要预先分配一定长度的存储空间，过大会造成存储浪费，过小会造成上溢

所以 在元素个数变化较大或未知时，最好用链表实现；如果事先知道线性表的大致长度，使用顺序表的空间效率会更高

## 线性表的其他存储方式
> `静态链表` 用数组来表示单链表，用数组元素下标来模拟单链表的指针。由于它是静态存储分配又模拟了单链表的结构，所以它叫静态链表。
>> 数组下标为0的结点往往作为头指针，first指向有效链，avail指向空闲链

> `间接寻址` 就是原本数组是存数据元素的，现在用来存放指向数据元素的指针，理论分析时间复杂度是没有变的，但从底层来看它对插入、删除操作会比线性表效率高

## 应用举例
> * 大整数求和，数据位数比较多无法用现有数据类型表示的时候，可能就是用数组的下标模拟对应的位进行相应的操作
> * 一元多项式求和 数据元素的个数难以确定所以采用 链表的形式

```javascript
// 我在处理的时候没有考虑到正负数，也就是说在相加的过程中有一些 项会被抵消会做删除结点的操作，哎我真的太粗心了
var obj = {
    c_value,
    c_sub,
    next
}

function sum(first_q,first_p){
    var q_pre = first_q,
        p_pre = first_p,
        q = q_pre -> next,
        p = p_pre -> next

    while(q!=null&&p!=null){
        if(q -> c_value < p->c_value){
            q_pre = q
            q = q -> next
        }else if(q -> c_value > p -> c_value){
            var temp = p -> next
            q_pre -> next = p
            p -> next = q
            p = temp
        }else{
            q -> c_value += q-> c_value
            if(q -> c_value == 0){
                q = q ->next
                q_pre -> next = q
            }else{
                q_pre = q
                q = q-> next
            }
            //本质上来说 p的前驱用不到的，因为是以 q 为主链的
            p = p -> next
        }
    }
    if(p!=null){
        q ->next = p
    }

    return q
}

顺序表 逆置算法

    function reverseSeq(seq){
        var arr = [],
            len = seq.length
        for(var i=0;i<len;i++){
            arr [i] = seq[len-1-i]
        }

        return arr;
    }

单链表 逆置算法

    对于单链表来说一定是有一个头结点的,并且它是不存在前驱的，所以这个逆置算法只能
    function reverseLinked(first){
        // 从头结点开始，一定是要置空处理的

        var one = q_pre = first -> next,   // 这边是获取第一个结点
            q = p -> next

我是在初始化第一个值的时候进行处理，就是这里能不能把它放进 循环中统一处理

        while(q!=null){
            var temp = q->next
            q -> next = q_pre
            q_pre = p
            q = temp
        }
// 增加尾结点标志
        one ->next = null

        return p
    }

    给2个单链表L1 L2 表示集合（结合元素的唯一性）,判断L1 是否是 L2 的子集

    如果L1 为空 则是L2的子集
    L1 不为空，就需要判断L1 中的元素是否在 L2中都存在
    时间复杂度是 O(n^2)
    function isSubSet(set1,set2){
        // 这里已经是获取到第一个结点的状态了

        if(set1!=null){
            while(set1!=null){
                var flag = true
                while(set2!=null){
                    if(set2 -> data == set1 -> data){
                        flag  = false;
                        break;
                    }
                    set2 = set2 -> next
                }
                if(flag){
                    return false;
                }
                set1 = set1 -> next
            }
        }
        // 从概念上来说，空集是任意集合的子集，意味着传入的2个是有先后顺序的，对于我来说
        return true;
    }

    商店仓库中，对电视机按其价格从低到高建立一个单链表，而链表的每一个结点指出同样价格的电视机台数，现有m台价格为n元的电视机入库
    // linked 应该是从头指针开始

    其实三个情况，分空链表，中间链表（已存在和不存），末尾链表，因为这是一个顺序表，唯一能优化的就是采用二分法插入，但又由于单链表并不是顺序表，所以二分法似乎 叉叉
    function Inser(linked,m,n){
        var p = linked -> next,
            p_pre = linked
        while(p!=null){
            if(p -> price == n){
                p -> count+=m
                break;
            }
            if(p -> price > n && p_pre -> price <n){
                // 插入
                p_pre -> next = point
                point -> next = p

                break;
            }

            p_pre = p
            p = p -> next
        }
        p -> next = point
        point -> next =null
    }

    没有头结点的单链表表示八进制数，要求写一个函数 Add，该函数有两个参数 P Q
    这种假发一定是涉及到进位的

// 以 P 为主链
    function Add(P,Q){
        var p = reverse(P),
            q = reverse(Q),
            flag = 0

         while(p!=null&&q!=null){
            var sum = p -> num + q -> num+flag,
                quotient = Math.floor(sum/8),
                remainder = sum%8
            if(quotient>0)
                flag = quotient
            else
                flag = 0

            p -> num = remainder

         }

        // 由于加法一般是从低位开始的，而这个链表头部表示的是高位，所以有必要先将链表进行逆置

        // 这里面不存在头结点
        function reverse(linked){

            if(linked -> next == null){
                throw new Error("The p_pre is mistake or bug");
            }

            var p_pre = linked,
                p = p_pre -> next,
                p_pre -> next =null

            while(p!=null){
                var temp = p -> next
                p -> next = p_pre
                p_pre = p
                p = temp
            }

            return p_pre
        }
    }

    设有编号 1、2、3 ... n 的n(n>0)个人围成一个圈，从第一个人开始报数，报到m时停止报数，第m个人出圈，直到所有人都出圈，计算求n个人的次序

    由于输出一个值会将该值从列表中删除，所以不存在用顺序表了，因为顺序表的增删消耗性能太大了，可以pass掉

    使用循环链表的时候几个细节还是需要处理的，加入链表为空null，单链表是单向的，所以处理起来很烦人

    // 假设这个循环链表有一个头指针
    function printList(linked,m){
        var p = linked,
            count =1,
            p_pre = p

            // 应该优先把 空链表以及单个链表处理掉

        // 大于2个值的链表
        // 只剩一个元素就跳出循环，
        while(p -> next != p){
            q_pre = p
            p = q_pre
            if(count==m){
                p -> next = p -> next -> next
            }
            count++
        }

        cout<< p -> num
    }

    4个人过桥问题是属于图的问题，不知道为什么会放到这个 线性表中。。。迪杰特斯拉 Dijkstra 是一个最短路径算法

    图graph 和 树tree ，是目前我的2大梦魇~~~
